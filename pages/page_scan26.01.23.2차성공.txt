# pages/page_scan.py

import os
import re
import platform
import datetime
from datetime import datetime as _dt, timedelta as _td

import streamlit as st
from PIL import Image, ImageOps, ImageFilter, ImageStat, Image as _PILImage

try:
    import pytesseract
except Exception:
    pytesseract = None

# ==== Tesseract ì‹¤í–‰ íŒŒì¼ ê²½ë¡œ (ë¡œì»¬/ì„œë²„ ê²¸ìš©) ====
if platform.system() == "Windows":
    # ë¡œì»¬ PC (Windows)ì—ì„œëŠ” ê¸°ë³¸ ì„¤ì¹˜ ê²½ë¡œ ì‚¬ìš©
    TESSERACT_ROOT = r"C:\Program Files\Tesseract-OCR"
    TESSERACT_EXE  = os.path.join(TESSERACT_ROOT, "tesseract.exe")
else:
    # Render ê°™ì€ ë¦¬ëˆ…ìŠ¤ ì„œë²„ì—ì„œëŠ” PATH ì— ìˆëŠ” tesseract ì‚¬ìš©
    # (ì˜ˆ: apt-get install tesseract-ocr ë¡œ ì„¤ì¹˜ëœ ë°”ì´ë„ˆë¦¬)
    TESSERACT_ROOT = ""
    TESSERACT_EXE  = "tesseract"


from config import (
    SESS_CURRENT_PAGE,
    PAGE_CUSTOMER,
)

from core.customer_service import (
    upsert_customer_from_scan,
)

# -----------------------------
# 1) Tesseract ê¸°ë³¸ ìœ í‹¸ (ê°„ë‹¨ ë²„ì „)
# -----------------------------

def _ensure_tesseract() -> bool:
    r"""Tesseract ì‹¤í–‰íŒŒì¼ & pytesseract ì—°ê²° í™•ì¸ (ë¡œì»¬/ì„œë²„ ê²¸ìš©).

    - Windows: C:\Program Files\Tesseract-OCR\tesseract.exe ì‚¬ìš©
    - Linux/ì„œë²„(Render ë“±): PATH ì— ìˆëŠ” `tesseract` ì‚¬ìš©
    """
    import streamlit as st
    import platform
    global pytesseract

    # 1) ëª¨ë“ˆ ì²´í¬
    if pytesseract is None:
        st.error("âŒ pytesseract ëª¨ë“ˆì´ ì—†ìŠµë‹ˆë‹¤. `pip install pytesseract` í›„ ë‹¤ì‹œ ì‹¤í–‰í•´ì£¼ì„¸ìš”.")
        return False

    system = platform.system()

    # 2) OSë³„ ì‹¤í–‰ íŒŒì¼ í™•ì¸
    if system == "Windows":
        if not os.path.exists(TESSERACT_EXE):
            st.error(
                "âŒ Tesseract ì‹¤í–‰íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
                f"ê¸°ëŒ€ ê²½ë¡œ: {TESSERACT_EXE}"
            )
            return False
        cmd = TESSERACT_EXE
    else:
        # ë¦¬ëˆ…ìŠ¤/ë§¥: PATH ì— ìˆëŠ” tesseract ì‚¬ìš©
        cmd = TESSERACT_EXE  # ë³´í†µ 'tesseract'

    # 3) ì—°ê²° + ë²„ì „ í™•ì¸
    try:
        pytesseract.pytesseract.tesseract_cmd = cmd
        ver = pytesseract.get_tesseract_version()
        st.info(f"âœ… Tesseract ì—°ê²° ì„±ê³µ: {ver} (cmd={cmd})")
        return True
    except Exception as e:
        if system == "Windows":
            more = "Tesseract-OCR ì„¤ì¹˜ ë° í™˜ê²½ë³€ìˆ˜ë¥¼ ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”."
        else:
            more = "Render ì„œë²„ì— `tesseract-ocr` íŒ¨í‚¤ì§€ê°€ ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”."
        st.error(f"âŒ Tesseract ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}\n{more}")
        return False



def _ocr(img, lang="kor", config="", timeout: int | None = None):
    """
    ê³µí†µ OCR ë˜í¼.
    - timeout: ì´ˆ ë‹¨ìœ„. ì§€ì •í•˜ë©´ í•´ë‹¹ ì‹œê°„ ë‚´ ì‘ë‹µ ì—†ì„ ë•Œ ì˜ˆì™¸ê°€ ë‚˜ë©°, ì—¬ê¸°ì„œëŠ” ë¹ˆ ë¬¸ìì—´ë¡œ ì²˜ë¦¬í•œë‹¤.
    """
    if pytesseract is None or img is None:
        return ""
    try:
        if timeout is None:
            return pytesseract.image_to_string(img, lang=lang, config=config) or ""
        return pytesseract.image_to_string(img, lang=lang, config=config, timeout=timeout) or ""
    except Exception:
        return ""



def _binarize(img):
    """
    ë‹¨ìˆœ ì´ì§„í™”(ë””ë²„ê·¸/ë³´ì¡°ìš©).
    """
    g = ImageOps.grayscale(img)
    return g.point(lambda p: 255 if p > 128 else 0)


def _binarize_soft(img):
    """
    MRZìš© 'ë¶€ë“œëŸ¬ìš´' ì´ì§„í™”:
    - ê·¸ë ˆì´ìŠ¤ì¼€ì¼
    - ì•½í•œ ë…¸ì´ì¦ˆ ì œê±°
    - ìë™ ëŒ€ë¹„ ì¡°ì •
    """
    g = ImageOps.grayscale(img)
    g = g.filter(ImageFilter.MedianFilter(size=3))
    g = ImageOps.autocontrast(g)
    return g


def _pre(img):
    """
    MRZìš© ê¸°ë³¸ ì „ì²˜ë¦¬:
    - ê·¸ë ˆì´ìŠ¤ì¼€ì¼ + ìë™ ëŒ€ë¹„
    """
    g = ImageOps.grayscale(img)
    g = ImageOps.autocontrast(g)
    return g


def ocr_try_all(
    img,
    langs=("kor", "kor+eng"),
    psms=(6, 7),
    pres=("raw", "binarize"),
    max_tries: int | None = None,
):
    """
    ë””ë²„ê·¸ìš© â€˜ë² ìŠ¤íŠ¸ OCRâ€™ íƒìƒ‰ (ê°„ì´ ë²„ì „).
    - text ê¸¸ì´ë¥¼ scoreë¡œ ì‚¬ìš©.
    - max_tries ê°€ None ì´ë©´: langsÃ—psmsÃ—pres ëª¨ë“  ì¡°í•© ì‹œë„ (ê¸°ì¡´ê³¼ ë™ì¼)
    - max_tries ê°€ 1,2,... ì´ë©´: ì•ì—ì„œë¶€í„° ìµœëŒ€ ê·¸ íšŸìˆ˜ë§Œ ì‹œë„
      (langs/psms/pres ê°’ ìì²´ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ê³ , 'ì¡°í•© ìˆ˜'ë§Œ ì¤„ì¸ë‹¤)
    """
    best = {"text": "", "lang": None, "config": "", "pre": None, "score": -1}
    if pytesseract is None or img is None:
        return best

    tried = 0
    for lang in langs:
        for psm in psms:
            for pre in pres:
                proc = img
                if pre == "binarize":
                    proc = _binarize(img)
                cfg = f"--oem 3 --psm {psm}"
                try:
                    txt = pytesseract.image_to_string(proc, lang=lang, config=cfg) or ""
                except Exception:
                    txt = ""
                score = len(txt.strip())
                if score > best["score"]:
                    best.update(text=txt, lang=lang, config=cfg, pre=pre, score=score)

                tried += 1
                if max_tries is not None and tried >= max_tries:
                    # ë¹ ë¥¸ ëª¨ë“œì¼ ë•Œ: ì•ì—ì„œë¶€í„° max_triesê°œ ì¡°í•©ë§Œ ì‹œë„
                    return best

    return best





# -----------------------------
# PDF â†’ Image (ì—¬ê¶Œ PDF ì§€ì›)
# -----------------------------

def _pdf_to_pil_images(pdf_bytes: bytes, max_pages: int = 10, zoom: float = 2.5):
    """PDF bytesë¥¼ PIL ì´ë¯¸ì§€ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜.
    - PyMuPDF(fitz) ì‚¬ìš©. (ì—†ìœ¼ë©´ ë¹ˆ ë¦¬ìŠ¤íŠ¸)
    - zoom 2.5 â‰’ 180~200dpi ìˆ˜ì¤€
    """
    try:
        import fitz  # pymupdf
    except Exception:
        return []

    imgs = []
    try:
        doc = fitz.open(stream=pdf_bytes, filetype="pdf")
        n = min(doc.page_count, max_pages)
        mat = fitz.Matrix(zoom, zoom)
        for i in range(n):
            page = doc.load_page(i)
            pix = page.get_pixmap(matrix=mat, alpha=False)
            img = Image.frombytes("RGB", (pix.width, pix.height), pix.samples)
            imgs.append(img)
        doc.close()
    except Exception:
        return []
    return imgs


_COUNTRY_CODE_MAP = {
    "KOR": "ëŒ€í•œë¯¼êµ­",
    "CHN": "ì¤‘êµ­",
    "VNM": "ë² íŠ¸ë‚¨",
    "USA": "ë¯¸êµ­",
    "JPN": "ì¼ë³¸",
    "PHL": "í•„ë¦¬í•€",
    "MNG": "ëª½ê³¨",
    "UZB": "ìš°ì¦ˆë² í‚¤ìŠ¤íƒ„",
    "KAZ": "ì¹´ìíìŠ¤íƒ„",
    "RUS": "ëŸ¬ì‹œì•„",
    "THA": "íƒœêµ­",
    "IDN": "ì¸ë„ë„¤ì‹œì•„",
    "MMR": "ë¯¸ì–€ë§ˆ",
    "NPL": "ë„¤íŒ”",
    "IND": "ì¸ë„",
    "PAK": "íŒŒí‚¤ìŠ¤íƒ„",
    "BGD": "ë°©ê¸€ë¼ë°ì‹œ",
}

def _country_name(alpha3: str) -> str:
    c = (alpha3 or "").strip().upper()
    if not c:
        return ""
    if c in _COUNTRY_CODE_MAP:
        return _COUNTRY_CODE_MAP[c]
    # pycountryê°€ ìˆìœ¼ë©´ ì˜ë¬¸ êµ­ê°€ëª…ì´ë¼ë„ í‘œì‹œ
    try:
        import pycountry
        rec = pycountry.countries.get(alpha_3=c)
        if rec and getattr(rec, "name", None):
            return str(rec.name)
    except Exception:
        pass
    return c
def open_image_safe(uploaded_file):
    """ì—…ë¡œë“œëœ íŒŒì¼ì„ ì•ˆì „í•˜ê²Œ PIL RGB ì´ë¯¸ì§€ë¡œ ì—¬ëŠ” í•¨ìˆ˜.

    - ì´ë¯¸ì§€(jpg/png/webp): ê·¸ëŒ€ë¡œ ì˜¤í”ˆ
    - PDF: 1í˜ì´ì§€ë¥¼ ë Œë”ë§í•´ì„œ ì´ë¯¸ì§€ë¡œ ë³€í™˜
    """
    if uploaded_file is None:
        return None

    # Streamlit UploadedFile
    name = getattr(uploaded_file, "name", "") or ""
    lower = name.lower()

    try:
        if lower.endswith(".pdf"):
            pdf_bytes = uploaded_file.getvalue()
            imgs = _pdf_to_pil_images(pdf_bytes, max_pages=1)
            return imgs[0].convert("RGB") if imgs else None

        return Image.open(uploaded_file).convert("RGB")
    except Exception:
        return None


# -----------------------------
# 2) ìŠ¤ìº”ìš© OCR ìœ í‹¸ (ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ)
# -----------------------------

# â”€â”€ ì†ë„/ì˜µì…˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ARC_REMOVE_PAREN = True   # ì£¼ì†Œì—ì„œ (ì‹ ê¸¸ë™) ê°™ì€ ê´„í˜¸í‘œê¸° ì œê±°
ARC_FAST_ONLY    = True   # ë¹ ë¥¸ ëª¨ë“œ(í•„ìš” ìµœì†Œ ì¡°í•©ë§Œ ì‹œë„)

# â”€â”€ MRZ(ì—¬ê¶Œ) ë³´ì¡° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_MRZ_CLEAN_TRANS = str.maketrans({'Â«':'<','â€¹':'<','>':'<',' ':'', 'â€”':'-', 'â€“':'-'})
def _normalize_mrz_line(s: str) -> str:
    s = (s or '').strip().translate(_MRZ_CLEAN_TRANS).upper()
    if s.startswith('PO'):
        s = 'P<' + s[2:]
    s = re.sub(r'[^A-Z0-9<]', '', s)
    if len(s) < 44: s += '<'*(44-len(s))
    elif len(s) > 44: s = s[:44]
    return s

def _is_td3_candidate(L1: str, L2: str) -> bool:
    if not (re.fullmatch(r'[A-Z0-9<]{44}', L1) and re.fullmatch(r'[A-Z0-9<]{44}', L2)): return False
    if not L1.startswith('P<'): return False
    if (L1+L2).count('<') < 20: return False
    if not re.fullmatch(r'[A-Z]{3}', L2[10:13]): return False   # êµ­ì 
    if L2[20] not in 'MF<': return False                        # ì„±ë³„
    if not re.fullmatch(r'\d{6}', re.sub(r'[^0-9]', '', L2[13:19])): return False # ìƒë…„
    if not re.fullmatch(r'\d{6}', re.sub(r'[^0-9]', '', L2[21:27])): return False # ë§Œê¸°
    return True

def find_mrz_pair_from_text(text: str):
    """
    OCR í…ìŠ¤íŠ¸ì—ì„œ TD3(MRZ 44x2) 2ì¤„ì„ ìµœëŒ€í•œ ì•ˆì •ì ìœ¼ë¡œ ì°¾ëŠ”ë‹¤.

    í•µì‹¬:
    - ì¤„ ê²½ê³„ê°€ ê¹¨ì ¸ '|'ë¡œ ë‘˜ì´ ë¶™ê±°ë‚˜(= 88ì+), ì•ë’¤ì— ì¡ë¬¸ì´ ì„ì—¬ë„ ì¡ë„ë¡
      "ì •ê·œí™”ëœ ë¬¸ì ìŠ¤íŠ¸ë¦¼"ì—ì„œ 44ì ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¡œ Line1/Line2 í›„ë³´ë¥¼ ì°¾ëŠ”ë‹¤.
    - ì„±ê³µ íŒì •ì€ 'L1/L2 ìœ„ì¹˜ ê·œì¹™' ê¸°ë°˜(êµ­ì /ì„±ë³„/ìƒë…„/ë§Œê¸° ìë¦¬)ìœ¼ë¡œ í•œë‹¤.
    - ì‹¤íŒ¨ ì‹œì—ëŠ” ê¸°ì¡´ ë¼ì¸ ê¸°ë°˜ ì¡°í•© ê²€ì‚¬ë¡œ fallback.
    ë°˜í™˜: (L1, L2) ë˜ëŠ” (None, None)
    """
    import re

    if not text:
        return (None, None)

    # 1) ì›ë¬¸ ë¼ì¸ ìˆ˜ì§‘
    raw_lines = [l.strip() for l in (text or "").splitlines() if l.strip()]

    # 2) "ë¬¸ì ìŠ¤íŠ¸ë¦¼" êµ¬ì„±: ë¼ì¸ë“¤ì„ ë¶™ì—¬ë†“ê³ , MRZì— í—ˆìš©ë˜ëŠ” ë¬¸ìë§Œ ë‚¨ê¸´ë‹¤.
    #    (íŒŒì´í”„/ê³µë°±/ì¡ë¬¸ìœ¼ë¡œ ì¸í•´ 44 ê²½ê³„ê°€ ì–´ê¸‹ë‚˜ë„, ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¡œ ì¬íƒìƒ‰ ê°€ëŠ¥)
    joined_raw = "<".join(raw_lines).upper().translate(_MRZ_CLEAN_TRANS)
    joined_raw = re.sub(r"[^A-Z0-9<]", "", joined_raw)

    def _norm44(s: str) -> str:
        s = (s or "").strip().upper().translate(_MRZ_CLEAN_TRANS)
        # 'PO'ë¡œ ì‹œì‘í•˜ëŠ” OCR ì˜¤ë¥˜(= P<) ë³´ì •
        if s.startswith("PO"):
            s = "P<" + s[2:]
        s = re.sub(r"[^A-Z0-9<]", "", s)
        if len(s) < 44:
            s += "<" * (44 - len(s))
        elif len(s) > 44:
            s = s[:44]
        return s

    def _looks_like_line2(L2: str) -> bool:
        # êµ­ì (10:13), ì„±ë³„(20), ìƒë…„(13:19), ë§Œê¸°(21:27) í˜•íƒœ ì²´í¬
        if not re.fullmatch(r"[A-Z0-9<]{44}", L2 or ""):
            return False
        if not re.fullmatch(r"[A-Z]{3}", (L2[10:13] or "")):
            return False
        if (L2[20] not in "MF<"):
            return False
        if not re.fullmatch(r"\d{6}", re.sub(r"[^0-9]", "", (L2[13:19] or ""))):
            return False
        if not re.fullmatch(r"\d{6}", re.sub(r"[^0-9]", "", (L2[21:27] or ""))):
            return False
        # ì—¬ê¶Œë²ˆí˜¸(0~8)ì— '<'ê°€ ê³¼ë„í•˜ë©´(ê±°ì˜ ê³µë°±) ì‹¤íŒ¨
        doc = (L2[0:9] or "")
        if doc.count("<") >= 5:
            return False
        return True

    def _looks_like_line1(L1: str) -> bool:
        if not re.fullmatch(r"[A-Z0-9<]{44}", L1 or ""):
            return False
        # 'PO'ë¡œ ì‹œì‘í•˜ëŠ” OCR ì˜¤ë¥˜(= P<)ëŠ” _norm44ì—ì„œ ì´ë¯¸ P<ë¡œ ë³´ì •ë¨
        if not L1.startswith("P<"):
            return False
        # ë°œí–‰êµ­/ë°œê¸‰êµ­ ì½”ë“œ(positions 3-5) 3ìë¦¬ ì˜ë¬¸
        if not re.fullmatch(r"[A-Z]{3}", (L1[2:5] or "")):
            return False
        # ì´ë¦„ êµ¬ë¶„ì ì¡´ì¬
        if ("<<" not in L1[5:]):
            return False
        # Line1 ëë¶€ë¶„ì€ ë³´í†µ filler('<')ê°€ ë§ì´ ê¹”ë¦°ë‹¤.
        # ê²½ê³„ê°€ í‹€ì–´ì ¸ Line2(ì—¬ê¶Œë²ˆí˜¸)ê°€ ì„ì´ë©´ ì—¬ê¸°ì„œ ê±¸ëŸ¬ì§.
        tail = L1[-10:]
        if tail.count("<") < 5:
            return False
        return True

    # 3) ìŠ¬ë¼ì´ë”© ìœˆë„ìš° í›„ë³´ íƒìƒ‰
    best = None  # (score, pos1, L1, pos2, L2)
    S = joined_raw

    if len(S) >= 60:  # ë„ˆë¬´ ì§§ìœ¼ë©´ ì˜ë¯¸ ì—†ìŒ
        win_candidates_1 = []
        win_candidates_2 = []

        # 44ì ìœˆë„ìš° ìŠ¤ìº” (ê³¼í•˜ê²Œ ëŠë ¤ì§€ì§€ ì•Šë„ë¡ ìµœëŒ€ ê¸¸ì´ ì œí•œ)
        # ì¼ë°˜ ìŠ¤ìº”ë³¸/ì‚¬ì§„ì—ì„œ S ê¸¸ì´ëŠ” ìˆ˜ë°±~ìˆ˜ì²œ ìˆ˜ì¤€ì´ì–´ì„œ ì¶©ë¶„íˆ ê°ë‹¹ ê°€ëŠ¥.
        max_scan_len = 8000
        if len(S) > max_scan_len:
            S = S[:max_scan_len]

        for i in range(0, len(S) - 44 + 1):
            w = _norm44(S[i:i+44])
            if _looks_like_line1(w):
                win_candidates_1.append((i, w))
            if _looks_like_line2(w):
                win_candidates_2.append((i, w))

        # í›„ë³´ í˜ì–´ë§: Line2ëŠ” Line1 ë’¤ìª½ì— ê°€ê¹ê²Œ(ëŒ€ê°œ 44 ê·¼ì²˜) ìœ„ì¹˜
        for (p1, L1) in win_candidates_1:
            for (p2, L2) in win_candidates_2:
                if p2 <= p1:
                    continue
                dist = p2 - p1
                # ë„ˆë¬´ ê°€ê¹ê±°ë‚˜ ë„ˆë¬´ ë©€ë©´ ë°°ì œ (ì •ìƒ TD3ëŠ” ëŒ€ê°œ 44 ê·¼ì²˜)
                if dist < 30:
                    continue
                # ë„ˆë¬´ ë©€ë©´(ì¡ë¬¸ ì„ì„) ë°°ì œ
                if dist > 80:
                    continue
                # ì ìˆ˜: '<' ê°œìˆ˜ + ì¸ì ‘ì„± ë³´ë„ˆìŠ¤
                base = (L1 + L2).count("<")
                # ì¸ì ‘ì„±: 44ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ê°€ì‚°
                prox = max(0, 60 - abs(dist - 44))
                score = base + prox
                if (best is None) or (score > best[0]):
                    best = (score, p1, L1, p2, L2)

    if best:
        return (best[2], best[4])

    # 4) fallback: ë¼ì¸ ë‹¨ìœ„ ì •ê·œí™” í›„, ëª¨ë“  ì¡°í•© ê²€ì‚¬
    cand_lines = []
    for l in raw_lines:
        nl = _norm44(l)
        if nl:
            cand_lines.append(nl)

    # 88ì(ë¶™ì€ 2ì¤„) ë¶„í•´ë„ ë¼ì¸ ê¸°ë°˜ìœ¼ë¡œ í•œ ë²ˆ ë”
    expanded = []
    for nl in cand_lines:
        if len(nl) >= 88:
            expanded.append(_norm44(nl[:44]))
            expanded.append(_norm44(nl[44:88]))
        else:
            expanded.append(_norm44(nl))
    # ì¤‘ë³µ ì œê±°(ìˆœì„œ ìœ ì§€)
    seen = set()
    uniq = []
    for l in expanded:
        if l in seen:
            continue
        seen.add(l)
        uniq.append(l)

    best2 = None
    for i in range(len(uniq)):
        for j in range(len(uniq)):
            if i == j:
                continue
            L1, L2 = uniq[i], uniq[j]
            L1n = _norm44(L1)
            L2n = _norm44(L2)
            if _looks_like_line1(L1n) and _looks_like_line2(L2n):
                score = (L1n + L2n).count("<")
                if (best2 is None) or (score > best2[0]):
                    best2 = (score, L1n, L2n)

    return (best2[1], best2[2]) if best2 else (None, None)

def _minus_years(d: _dt.date, years: int) -> _dt.date:
    y = d.year - years
    import calendar
    endday = calendar.monthrange(y, d.month)[1]
    return _dt(y, d.month, min(d.day, endday)).date()


def _parse_mrz_name_from_L1(L1: str) -> tuple[str, str]:
    """MRZ 1ì¤„(L1)ì—ì„œ (ì„±, ëª…)ì„ ìµœëŒ€í•œ ë³´ìˆ˜ì ìœ¼ë¡œ ì¶”ì¶œ.
    - í‘œì¤€: SURNAME<<GIVEN<NAMES
    - OCRì´ '<' í•˜ë‚˜ë¥¼ ëˆ„ë½í•´ SURNAME<GIVEN ì²˜ëŸ¼ ë“¤ì–´ì˜¤ëŠ” ê²½ìš°ê°€ ìˆì–´ fallbackì„ ë‘”ë‹¤.
    - íŒ¨ë”© êµ¬ê°„(<<<... ) ì´í›„ëŠ” ë²„ë¦°ë‹¤.
    """
    if not L1:
        return ("", "")
    L1 = _normalize_mrz_line(L1)
    if not L1.startswith("P<"):
        return ("", "")

    field = L1[5:]  # êµ­ê°€ì½”ë“œ(3) ì´í›„ ì´ë¦„í•„ë“œ ì‹œì‘

    # í‘œì¤€ êµ¬ë¶„ì ìš°ì„ 
    if "<<" in field:
        sur_raw, given_raw = field.split("<<", 1)
    else:
        # fallback: ì²« '<'ë¥¼ ì„±/ëª… ê²½ê³„ë¡œ ê°„ì£¼ (ìš°ì¦ˆë²¡ ë“±ì—ì„œ OCR ëˆ„ë½ ì¼€ì´ìŠ¤ ëŒ€ì‘)
        p = field.find("<")
        if p <= 0:
            return ("", "")
        sur_raw, given_raw = field[:p], field[p+1:]

    def _clean(part: str) -> str:
        part = re.sub(r"[^A-Z<]", "", (part or "").upper())
        # ë§ˆì§€ë§‰ ì´ë¦„ ë’¤ì˜ íŒ¨ë”©(<<<...) ì œê±°
        part = re.split(r"<{3,}", part, maxsplit=1)[0]
        part = part.strip("<")
        part = part.replace("<", " ").strip()
        part = re.sub(r"\s{2,}", " ", part)
        return part

    return (_clean(sur_raw), _clean(given_raw))


def _parse_mrz_pair(L1: str, L2: str) -> dict:
    out = {}

    # None ë°©ì§€ + ì •ê·œí™”
    L1 = _normalize_mrz_line(L1) if L1 else ""
    L2 = _normalize_mrz_line(L2) if L2 else ""

    # ğŸ”¹ ì´ë¦„: MRZ 1ì¤„ì—ì„œ (ì„±/ëª…) ì¶”ì¶œ
    sur, given = _parse_mrz_name_from_L1(L1)
    if sur:
        out["ì„±"] = sur
    if given:
        out["ëª…"] = given


    # ì—¬ê¶Œ, êµ­ì , ìƒë…„, ì„±ë³„, ë§Œê¸° (ê¸°ì¡´ ë¡œì§ ê·¸ëŒ€ë¡œ)
    pn = re.sub(r"[^A-Z0-9]", "", L2[0:9])
    if pn:
        out["ì—¬ê¶Œ"] = pn

    nat = re.sub(r"[^A-Z]", "", L2[10:13])
    if nat:
        # OCR ì˜¤ì¸ì‹ ë³´ì • (ì˜ˆ: UZBê°€ JZBë¡œ ì˜ëª» ì¡íˆëŠ” ì¼€ì´ìŠ¤)
        if nat == "JZB":
            nat = "UZB"
        elif nat == "OZB":
            nat = "UZB"
        out["êµ­ê°€"] = nat

    b = re.sub(r"[^0-9]", "", L2[13:19])
    if len(b) == 6:
        yy, mm, dd = int(b[:2]), int(b[2:4]), int(b[4:6])
        # MRZì˜ 2ìë¦¬ ì—°ë„ëŠ” ì„¸ê¸°ê°€ ëª…ì‹œë˜ì§€ ì•ŠìŒ â†’ 'í˜„ì‹¤ì ì¸ ìƒë…„'ìœ¼ë¡œ ì„¸ê¸° ê²°ì •
        try:
            today = _dt.today().date()
            cand_years = [1900 + yy, 2000 + yy]
            best_date = None
            best_score = None
            for y in cand_years:
                try:
                    d = _dt(y, mm, dd).date()
                except Exception:
                    continue
                age = (today - d).days / 365.25
                # ìƒë…„ì€ ë¯¸ë˜ì¼ ìˆ˜ ì—†ê³ , í†µìƒ 0~120ì„¸ ë²”ìœ„
                if d > today:
                    continue
                if not (0 <= age <= 120):
                    continue
                # 0~100ì„¸ ë²”ìœ„ë¥¼ ìš°ì„ (í˜„ì‹¤ì  ê°€ì¤‘ì¹˜)
                score = (0 if age <= 100 else 50) + abs(age - 35)  # 35ì„¸ ê·¼ì²˜ë¥¼ ì•½ê°„ ì„ í˜¸
                if (best_score is None) or (score < best_score):
                    best_score = score
                    best_date = d
            if best_date:
                out["ìƒë…„ì›”ì¼"] = best_date.strftime("%Y-%m-%d")
        except Exception:
            pass


    sx = L2[20:21]
    out["ì„±ë³„"] = "ë‚¨" if sx == "M" else ("ì—¬" if sx == "F" else "")

    e = re.sub(r"[^0-9]", "", L2[21:27])
    if len(e) == 6:
        yy, mm, dd = int(e[:2]), int(e[2:4]), int(e[4:6])
        # ë§Œê¸°ì¼ì€ í†µìƒ 'í˜„ì¬Â±ëª‡ ë…„' ë²”ìœ„ì— ì¡´ì¬ â†’ ê·¸ ë²”ìœ„ì— ë§ëŠ” ì„¸ê¸° ì„ íƒ
        try:
            today = _dt.today().date()
            cand_years = [1900 + yy, 2000 + yy]
            best_date = None
            best_score = None
            for y in cand_years:
                try:
                    d = _dt(y, mm, dd).date()
                except Exception:
                    continue
                # ë§Œê¸°ì¼ì€ ê³¼ê±°ë¼ë„ ë„ˆë¬´ ì˜¤ë˜ëœ ê°’(ì˜ˆ: 1928)ì€ ë¹„í˜„ì‹¤ì 
                if d < (today.replace(year=today.year - 15)):
                    continue
                if d > (today.replace(year=today.year + 25)):
                    continue
                # ê°€ê¹Œìš´ ë¯¸ë˜(ë˜ëŠ” ìµœê·¼ ê³¼ê±°)ë¥¼ ì„ í˜¸
                score = abs((d - today).days)
                if (best_score is None) or (score < best_score):
                    best_score = score
                    best_date = d
            if best_date:
                out["ë§Œê¸°"] = best_date.strftime("%Y-%m-%d")
        except Exception:
            # fallback (ê¸°ì¡´ ê·œì¹™)
            yy2 = 2000 + yy if yy < 80 else 1900 + yy
            try:
                out["ë§Œê¸°"] = _dt(yy2, mm, dd).strftime("%Y-%m-%d")
            except Exception:
                pass


    # ğŸ‘‰ ë°œê¸‰ì¼: 10ë…„ì§œë¦¬ ê¸°ì¤€ ì—­ì‚° (+1ì¼) ê·¸ëŒ€ë¡œ ìœ ì§€
    if out.get("ë§Œê¸°"):
        try:
            exp = _dt.strptime(out["ë§Œê¸°"], "%Y-%m-%d").date()
            issued = _minus_years(exp, 10) + _td(days=1)
            out["ë°œê¸‰"] = issued.strftime("%Y-%m-%d")
        except Exception:
            pass

    return out


def _mrz_char_value(ch: str) -> int:
    if ch == '<':
        return 0
    if '0' <= ch <= '9':
        return ord(ch) - ord('0')
    if 'A' <= ch <= 'Z':
        return ord(ch) - ord('A') + 10
    return 0

def _mrz_check_digit(data: str) -> str:
    weights = (7, 3, 1)
    s = 0
    for i, ch in enumerate(data):
        s += _mrz_char_value(ch) * weights[i % 3]
    return str(s % 10)

def _mrz_td3_checksum_ok(L2: str) -> bool:
    """
    TD3(ì—¬ê¶Œ) ë¼ì¸2 ì²´í¬ì„¬ ê²€ì¦.
    - ë¬¸ì„œë²ˆí˜¸ / ìƒë…„ì›”ì¼ / ë§Œê¸°ì¼ / (ê°€ëŠ¥í•˜ë©´) ì¢…í•©ì²´í¬ì„¬
    """
    if not L2 or len(L2) != 44:
        return False

    # ë¬¸ì„œë²ˆí˜¸ 0-8, ì²´í¬ 9
    doc = L2[0:9]
    cd_doc = L2[9:10]
    if _mrz_check_digit(doc) != cd_doc:
        return False

    # ìƒë…„ì›”ì¼ 13-18, ì²´í¬ 19
    dob = L2[13:19]
    cd_dob = L2[19:20]
    if _mrz_check_digit(dob) != cd_dob:
        return False

    # ë§Œê¸°ì¼ 21-26, ì²´í¬ 27
    exp = L2[21:27]
    cd_exp = L2[27:28]
    if _mrz_check_digit(exp) != cd_exp:
        return False

    # ì¢…í•© ì²´í¬ì„¬ 43 (ê°€ëŠ¥í•˜ë©´ ê²€ì¦)
    comp = L2[0:10] + L2[13:20] + L2[21:28] + L2[28:43]
    cd_comp = L2[43:44]
    if cd_comp.isdigit() and _mrz_check_digit(comp) != cd_comp:
        return False

    return True

def _mrz_generate_variants(L2: str, max_variants: int = 16):
    """
    OCR ì˜¤ì¸ì‹(0/O, 1/I/L, 2/Z, 5/S, 6/G, 8/B) ë³´ì •ìš© ë³€í˜• í›„ë³´ ìƒì„±.
    ì²´í¬ì„¬ í†µê³¼ ê°€ëŠ¥í•œ L2ë¥¼ ì°¾ê¸° ìœ„í•œ ì œí•œëœ íƒìƒ‰.
    """
    if not L2 or len(L2) != 44:
        return [L2]

    swaps = {
        'O': '0', '0': 'O',
        'I': '1', '1': 'I',
        'L': '1',
        'Z': '2', '2': 'Z',
        'S': '5', '5': 'S',
        'G': '6', '6': 'G',
        'B': '8', '8': 'B',
    }

    # ì²´í¬ì„¬ì— í° ì˜í–¥ì„ ì£¼ëŠ” êµ¬ê°„ ìœ„ì£¼ë¡œë§Œ í›„ë³´ë¥¼ ë§Œë“ ë‹¤.
    idx_pool = list(range(0, 10)) + list(range(13, 20)) + list(range(21, 28)) + list(range(43, 44))
    idx_pool = [i for i in idx_pool if i < len(L2) and L2[i] in swaps]

    # ë„ˆë¬´ ë§ìœ¼ë©´ ì†ë„ ì €í•˜ â†’ ì•ìª½ ëª‡ ê°œë§Œ
    idx_pool = idx_pool[:8]

    variants = [L2]
    for i in idx_pool:
        new_variants = []
        for v in variants:
            ch = v[i]
            if ch not in swaps:
                continue
            v2 = v[:i] + swaps[ch] + v[i+1:]
            new_variants.append(v2)
        variants.extend(new_variants)
        # ì¤‘ë³µ ì œê±° + ì œí•œ
        variants = list(dict.fromkeys(variants))[:max_variants]
        if len(variants) >= max_variants:
            break

    return variants

def _auto_trim_white_border(img, thresh: int = 245, pad: int = 12):
    """
    ì—¬ê¶Œ/ìŠ¤ìº”ë³¸ ì£¼ë³€ì˜ í° í° ì—¬ë°± ì œê±° (ì†ë„/ì •í™•ë„ ëª¨ë‘ ê°œì„ ).
    - MRZê°€ 'í•˜ë‹¨ ë¹„ìœ¨ crop'ë¡œ ì•ˆ ì¡íˆëŠ” ìƒ˜í”Œ(í° ì—¬ë°± ìŠ¤ìº”)ì—ì„œ í•„ìˆ˜.
    """
    try:
        import numpy as np
        g = ImageOps.grayscale(img)
        arr = np.array(g)
        mask = arr < thresh
        if not mask.any():
            return img
        ys, xs = np.where(mask)
        x0, x1 = int(xs.min()), int(xs.max())
        y0, y1 = int(ys.min()), int(ys.max())
        x0 = max(0, x0 - pad)
        y0 = max(0, y0 - pad)
        x1 = min(arr.shape[1]-1, x1 + pad)
        y1 = min(arr.shape[0]-1, y1 + pad)
        return img.crop((x0, y0, x1+1, y1+1))
    except Exception:
        return img

def _estimate_mrz_center_rel(img, down_w: int = 900):
    """
    ì—¬ëŸ¬ ì—…ì²´/ìŠ¤ìº” ë°©ì‹(ì—¬ë°± í° PDF, ì‚¬ì§„ ì´¬ì˜) í˜¼ì¬ ìƒ˜í”Œ ëŒ€ì‘:
    - ì—ì§€ ë°€ë„(í–‰ë³„ Canny edge ë¹„ìœ¨)ë¡œ MRZê°€ ìˆëŠ” 'ê°€ë¡œ í…ìŠ¤íŠ¸ ë°€ì§‘ ë ' ì¤‘ì‹¬ì„ ì¶”ì •í•œë‹¤.
    - ë°˜í™˜: ì¤‘ì‹¬ y(0~1) or None
    """
    try:
        import numpy as np
        import cv2

        w0, h0 = img.size
        if w0 <= 0 or h0 <= 0:
            return None

        h_ds = max(200, int(down_w * (h0 / float(w0))))
        g = ImageOps.grayscale(img.resize((down_w, h_ds), resample=_PILImage.BILINEAR))
        a = np.array(g)
        edges = cv2.Canny(a, 50, 150)
        row_edge = edges.mean(axis=1).astype(float)

        # ì•½ê°„ í‰í™œí™”
        k = 31
        kernel = np.ones(k) / k
        row_s = np.convolve(row_edge, kernel, mode="same")

        h = len(row_s)
        # MRZëŠ” ë³´í†µ í•˜ë‹¨ë¶€ì— ìˆìœ¼ë¯€ë¡œ í•˜ë‹¨ ìª½(35%~98%)ì—ì„œ peak íƒìƒ‰
        lo, hi = int(h * 0.35), int(h * 0.98)
        if hi <= lo:
            return None
        idx = int(np.argmax(row_s[lo:hi])) + lo
        return idx / float(h)
    except Exception:
        return None

def _mrz_preprocess_variants(img_band):
    """
    MRZ ì¸ì‹ìš© ì „ì²˜ë¦¬ 2ì¢…ë§Œ ìœ ì§€ (ì†ë„ ë³´í˜¸).
    1) clahe+otsu (ëŒ€ë¶€ë¶„ ìŠ¤ìº”ë³¸ì—ì„œ ê°•í•¨)
    2) raw gray (ê³¼ì „ì²˜ë¦¬ë¡œ ê¸€ìê°€ ë‚ ì•„ê°€ëŠ” ì¼€ì´ìŠ¤ ëŒ€ë¹„)
    """
    variants = []
    try:
        import numpy as np
        import cv2

        g = np.array(ImageOps.grayscale(img_band))
        g = cv2.GaussianBlur(g, (3, 3), 0)

        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        g2 = clahe.apply(g)

        _, b = cv2.threshold(g2, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

        # í‘ë°± ë°˜ì „ì´ í•„ìš”í•œ ê²½ìš°(ë¬¸ì„œê°€ ì–´ë‘¡ê²Œ ìŠ¤ìº”ëœ ì¼€ì´ìŠ¤)
        if b.mean() < 127:
            b = 255 - b

        variants.append(("clahe_otsu", Image.fromarray(b)))
    except Exception:
        pass

    variants.append(("raw", ImageOps.grayscale(img_band)))
    return variants

def _ocr_mrz_block_eng(im, psm: int):
    # MRZëŠ” ì˜ë¬¸/ìˆ«ì/<ë§Œ ìˆìœ¼ë¯€ë¡œ eng + whitelist ë¡œ ì œí•œí•œë‹¤.
    cfg = (
        f"--oem 3 --psm {psm} "
        "-c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ<0123456789 "
        "-c load_system_dawg=0 -c load_freq_dawg=0"
    )
    return _ocr(im, lang="eng", config=cfg, timeout=3)

def _scan_mrz_candidates(img):
    """
    ìƒ˜í”Œ ê¸°ë°˜ ìµœì í™”(ì†ë„ ìš°ì„  + ì¸ì‹ë¥  ìœ ì§€):
    - 1) í° ì—¬ë°± ìë™ íŠ¸ë¦¬ë°(í° ì—¬ë°± ìŠ¤ìº” ëŒ€ì‘)
    - 2) ì—ì§€ ê¸°ë°˜ìœ¼ë¡œ MRZ ë  ì¤‘ì‹¬ ì¶”ì • â†’ 'ê·¸ ë 'ë§Œ ë¨¼ì € OCR (ì´ˆê³ ì†)
    - 3) ì‹¤íŒ¨ ì‹œ í•˜ë‹¨ ë¹„ìœ¨ crop(ì‚¬ì§„ ì´¬ì˜/ì—¬ê¶Œí˜ì´ì§€ ì „ì²´ìƒ· ëŒ€ì‘)
    - 4) íšŒì „ì€ 0/180 ìš°ì„ , ìµœí›„ì—ë§Œ 90/270
    ë°˜í™˜: (L1, L2, debug_info)
    """
    if img is None:
        return (None, None, {})

    img2 = _auto_trim_white_border(img)

    # ğŸ”¹ ì†ë„/ì •í™•ë„ ë°¸ëŸ°ìŠ¤: 1800px (PDF/ì €í•´ìƒ ìŠ¤ìº”ì—ì„œ MRZë¥¼ ì‚´ë¦¬ë©´ì„œë„ ê³¼ë¶€í•˜ ë°©ì§€)
    max_side = 1800
    w0, h0 = img2.size
    sc = max_side / float(max(w0, h0))
    if sc < 1.0:
        img2 = img2.resize((int(w0 * sc), int(h0 * sc)), resample=_PILImage.LANCZOS)

    debug = {"tries": [], "ocr_calls": 0, "max_ocr_calls": 8}

    def _iter_bands(img_rot, mode: str):
        """
        mode:
          - 'edge_fast' : ì—ì§€ ì¤‘ì‹¬ band 1~2ê°œë§Œ
          - 'edge_full' : ì—ì§€ ì¤‘ì‹¬ band 2ê°œ
          - 'bottom'    : í•˜ë‹¨ ë¹„ìœ¨ crop 4ê°œ
        """
        w, h = img_rot.size

        if mode.startswith("edge"):
            center = _estimate_mrz_center_rel(img_rot)
            if center is None:
                return
            centers = [center]
            if mode == "edge_full":
                centers.append(min(0.98, max(0.02, center + 0.06)))
            for c in centers:
                top = int(max(0.0, c - 0.16) * h)
                bot = int(min(1.0, c + 0.16) * h)
                yield (f"edge@{c:.2f}", img_rot.crop((0, top, w, bot)))

        if mode == "bottom":
            for crop in (0.28, 0.35):
                top = int(h * (1.0 - crop))
                yield (f"bottom@{crop:.2f}", img_rot.crop((0, top, w, h)))

    def _try_ocr_on_band(band, rot_deg: int, band_tag: str, stage: str):
        bw, bh = band.size
        if bw < 1400:
            s = 1400 / float(bw)
            band = band.resize((int(bw * s), int(bh * s)), resample=_PILImage.LANCZOS)

        # stage ë³„ë¡œ ì‹œë„ íšŸìˆ˜ë¥¼ ì œí•œ (ì†ë„ ë³´í˜¸)
        if stage == "FAST":
            pres = _mrz_preprocess_variants(band)[:1]   # clahe_otsuë§Œ
            psms = (7,)                                  # psm 7ë§Œ
        elif stage == "MID":
            pres = _mrz_preprocess_variants(band)        # clahe_otsu + raw
            psms = (7, 6)
        else:
            pres = _mrz_preprocess_variants(band)        # ë™ì¼
            psms = (7, 6)

        for pre_name, pre_img in pres:
            for psm in psms:
                if debug["ocr_calls"] >= debug["max_ocr_calls"]:
                    return (None, None)
                txt = _ocr_mrz_block_eng(pre_img, psm=psm) or ""
                debug["ocr_calls"] += 1
                L1, L2 = find_mrz_pair_from_text(txt)

                ok = False
                if L1 and L2:
                    L2n = _normalize_mrz_line(L2)
                    for v in _mrz_generate_variants(L2n):
                        if _mrz_td3_checksum_ok(v):
                            L2 = v
                            ok = True
                            break

                debug["tries"].append({"stage": stage, "rot": rot_deg, "band": band_tag, "pre": pre_name, "psm": psm, "ok": ok})
                if ok:
                    return (L1, L2)
        return (None, None)

    # â”€â”€ Stage 1: ì´ˆê³ ì† (0/180, edge band 1ê°œ, clahe_otsu + psm7ë§Œ)
    for rot in (0, 180):
        imr = img2.rotate(rot, expand=True) if rot else img2
        for tag, band in _iter_bands(imr, mode="edge_fast"):
            L1, L2 = _try_ocr_on_band(band, rot_deg=rot, band_tag=tag, stage="FAST")
            if L1 and L2:
                return (L1, L2, debug)

    # â”€â”€ Stage 2: ì¤‘ê°„(0/180, edge band 2ê°œ + bottom crop, ì „ì²˜ë¦¬2ì¢… + psm7/6)
    for rot in (0, 180):
        imr = img2.rotate(rot, expand=True) if rot else img2

        for tag, band in _iter_bands(imr, mode="edge_full"):
            L1, L2 = _try_ocr_on_band(band, rot_deg=rot, band_tag=tag, stage="MID")
            if L1 and L2:
                return (L1, L2, debug)

        for tag, band in _iter_bands(imr, mode="bottom"):
            L1, L2 = _try_ocr_on_band(band, rot_deg=rot, band_tag=tag, stage="MID")
            if L1 and L2:
                return (L1, L2, debug)

    # â”€â”€ Stage 3: ìµœí›„(90/270, edge 1ê°œ + bottom 1ê°œ, clahe_otsu + psm7/6)
    for rot in (90, 270):
        imr = img2.rotate(rot, expand=True)

        for tag, band in _iter_bands(imr, mode="edge_fast"):
            L1, L2 = _try_ocr_on_band(band, rot_deg=rot, band_tag=tag, stage="SLOW")
            if L1 and L2:
                return (L1, L2, debug)

        # bottomì€ 0.35 í•œ ë²ˆë§Œ (ì†ë„ ë³´í˜¸)
        w, h = imr.size
        tag = "bottom@0.35"
        band = imr.crop((0, int(h * (1.0 - 0.35)), w, h))
        L1, L2 = _try_ocr_on_band(band, rot_deg=rot, band_tag=tag, stage="SLOW")
        if L1 and L2:
            return (L1, L2, debug)

    return (None, None, debug)


def parse_passport(img):
    """
    TD3 ì—¬ê¶Œ: MRZ(2ì¤„ 44ì) ê¸°ë°˜ìœ¼ë¡œ í•„ë“œë¥¼ íŒŒì‹±í•œë‹¤.
    - ë‹¤ì–‘í•œ ìŠ¤ìº”/ì‚¬ì§„/ë°©í–¥/ì—¬ë°± ì¼€ì´ìŠ¤ë¥¼ 'íŠ¸ë¦¬ë° + ì—ì§€ê¸°ë°˜ band'ë¡œ ìš°ì„  í•´ê²°
    - ì„±ê³µ íŒì •ì€ "ì²´í¬ì„¬ í†µê³¼"ë¡œë§Œ í•œë‹¤ (ì†ë„/ì •í™•ë„ ë™ì‹œ í™•ë³´)
    """
    if img is None:
        return {}

    # 1) MRZ 2ì¤„ ì°¾ê¸°
    L1, L2, _dbg = _scan_mrz_candidates(img)
    if not L1 or not L2:
        return {}

    # 2) íŒŒì‹±
    out = _parse_mrz_pair(L1, L2)

    # 3) ì—¬ê¶Œë²ˆí˜¸ëŠ” 0~8(ì²´í¬ë””ì§€íŠ¸ ì œì™¸)ë§Œ ì‚¬ìš©
    if out.get("ì—¬ê¶Œ"):
        out["ì—¬ê¶Œ"] = out["ì—¬ê¶Œ"].replace("<", "")[:9]

    # 3.5) ì´ë¦„ í’ˆì§ˆ ë³´ì •: MRZ ì´ë¦„(íŠ¹íˆ ëª…)ì´ ì‹¬í•˜ê²Œ ê¹¨ì§„ ê²½ìš°ì—ë§Œ
    #      ë¹„ì£¼ì–¼ì¡´(ìƒë‹¨ë¶€)ì—ì„œ 1íšŒ OCRë¡œ ë¼ë²¨ ê¸°ë°˜ ì¶”ì¶œì„ ì‹œë„í•œë‹¤. (ì†ë„ ë³´í˜¸)
    def _name_suspicious(s: str) -> bool:
        s = (s or "").strip().upper()
        if not s:
            return True
        if any(ch.isdigit() for ch in s) or len(s) < 3:
            return True
        vowels = sum(ch in "AEIOUY" for ch in s)
        letters = sum("A" <= ch <= "Z" for ch in s)
        # ììŒë§Œ ê¸¸ê²Œ ì—°ì†ë˜ëŠ” ê°’(ì˜ˆ: PRJZBM)ì€ ëŒ€ê°œ OCR ê¹¨ì§
        if letters >= 5 and vowels == 0:
            return True
        return False

    if _name_suspicious(out.get("ëª…", "")) and out.get("ì„±"):
        try:
            w2, h2 = img.size
            viz = img.crop((0, 0, w2, int(h2 * 0.72)))
            viz_txt = _ocr(viz, lang="eng", config="--oem 3 --psm 6") or ""
            viz_up = re.sub(r"\s+", " ", viz_txt.upper())

            m_sur = re.search(r"(SURNAME|FAMILY\s*NAME)\s*[:\-]?\s*([A-Z][A-Z \-]{2,})", viz_up)
            m_giv = re.search(r"(GIVEN\s*NAMES?|GIVEN\s*NAME)\s*[:\-]?\s*([A-Z][A-Z \-]{2,})", viz_up)
            if m_sur:
                out["ì„±"] = re.sub(r"\s{2,}", " ", m_sur.group(2)).strip()
            if m_giv:
                out["ëª…"] = re.sub(r"\s{2,}", " ", m_giv.group(2)).strip()
        except Exception:
            pass

    return {
        "ì„±":       out.get("ì„±", ""),
        "ëª…":       out.get("ëª…", ""),
        "ì—¬ê¶Œ":     out.get("ì—¬ê¶Œ", ""),
        "ë°œê¸‰":     out.get("ë°œê¸‰", ""),
        "ë§Œê¸°":     out.get("ë§Œê¸°", ""),
        "êµ­ê°€":     out.get("êµ­ê°€", ""),
        "ì„±ë³„":     out.get("ì„±ë³„", ""),
        "ìƒë…„ì›”ì¼": out.get("ìƒë…„ì›”ì¼", ""),
    }


# ë“±ë¡ì¦(ARC) ê´€ë ¨ ë³´ì¡° ì •ê·œì‹/í•¨ìˆ˜ë“¤ (ì‚¬ìš©í•˜ë˜ ë²„ì „ ê·¸ëŒ€ë¡œ)
_ADDR_BAN_RE = re.compile(
    r'(ìœ íš¨|ì·¨ì—…|ê°€ëŠ¥|í™•ì¸|ë¯¼ì›|êµ­ë²ˆì—†ì´|ì½œì„¼í„°|call\s*center|www|http|1345|ì¶œì…êµ­|immigration|ì•ˆë‚´|ê´€í• |ê´€ê³„ì|ì™¸|ê¸ˆì§€)',
    re.I
)
# â”€â”€ ì´ë¦„ ì¶”ì¶œ ë³´ì¡° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_NAME_BAN = {
    "ì™¸êµ­", "êµ­ë‚´", "ê±°ì†Œ", "ì‹ ê³ ", "ì¦", "ì¬ì™¸ë™í¬", "ì¬ì™¸ë™","ì™¸ë™í¬",
    "ì¬ì™¸", "ë™í¬", "êµ­ì ", "ì£¼ì†Œ", "ë°œê¸‰", "ë°œê¸‰ì¼", "ë°œê¸‰ì¼ì",
    "ë§Œê¸°", "ì²´ë¥˜", "ìê²©", "ì¢…ë¥˜", "ì„±ëª…", "ì´ë¦„", "ì‚¬ë ¥"
}

def _extract_kor_name_strict(text: str) -> str:
    """
    ë“±ë¡ì¦ ì•ë©´ ì „ì²´ í…ìŠ¤íŠ¸ì—ì„œ í•œê¸€ ì´ë¦„ 2~3ê¸€ìë¥¼ ìµœëŒ€í•œ ì•ˆì „í•˜ê²Œ ì¶”ì¶œ
    0ìˆœìœ„: ê´„í˜¸ ì•ˆ í•œê¸€ ì´ë¦„ 2~4ê¸€ì  (ì˜ˆ: LI FENZI(ì´ë¶„ì))
    1ìˆœìœ„: 'ì„±ëª…' / 'ì´ë¦„' ë’¤ì˜ 2~3ê¸€ì
    2ìˆœìœ„: ì „ì²´ì—ì„œ 2~3ê¸€ì í† í° ì¤‘ ë¼ë²¨ ê·¼ì²˜ì— ìˆëŠ” ê²ƒ
    """
    if not text:
        return ""

    # 0) ê´„í˜¸ ì•ˆ í•œê¸€ ì´ë¦„ ì˜ˆ: LI FENZI(ì´ë¶„ì)
    m = re.search(r"\(([ê°€-í£]{2,4})\)", text)
    if m:
        cand = m.group(1)
        if cand not in _NAME_BAN:
            return cand

    # 1) 'ì„±ëª…: ì´ë¶„' / 'ì„±ëª… ì´ë¶„' íŒ¨í„´
    m = re.search(r"(ì„±ëª…|ì´ë¦„)\s*[:\-]?\s*([ê°€-í£]{2,3})", text)
    if m:
        cand = m.group(2)
        if cand not in _NAME_BAN:
            return cand

    # 2) ì „ì²´ì—ì„œ í•œê¸€ 2~3ê¸€ì í† í° í›„ë³´
    toks = re.findall(r"[ê°€-í£]{2,3}", text)
    toks = [t for t in toks if t not in _NAME_BAN]
    if not toks:
        return ""

    # 'ì„±ëª…' / 'ì´ë¦„' ë¼ë²¨ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ê°€ì¥ ê°€ê¹Œìš´ í† í° ì„ íƒ
    label_pos_list = [p for p in (text.find("ì„±ëª…"), text.find("ì´ë¦„")) if p != -1]
    label_pos = min(label_pos_list) if label_pos_list else len(text) // 2

    best, best_d = "", 10**9
    for t in toks:
        p = text.find(t)
        if p == -1:
            continue
        d = abs(p - label_pos)
        if d < best_d:
            best, best_d = t, d

    return best

def _kor_count(s: str) -> int:
    return len(re.findall(r'[ê°€-í£]', s or ''))

def parse_arc(img, fast: bool = False):
    """
    ë“±ë¡ì¦ ì´ë¯¸ì§€ íŒŒì„œ.
    - fast=True  ì´ë©´:
        * ë“±ë¡ì¦ ì „ì²´ ì´ë¯¸ì§€ë¥¼ í•œ ë³€ ìµœëŒ€ 1600pxë¡œ ë¦¬ì‚¬ì´ì¦ˆ
        * ìƒë‹¨ OCR ì‹œ ocr_try_all ì„ ìµœëŒ€ 2íšŒê¹Œì§€ë§Œ ì‹œë„
    - fast=False ì´ë©´:
        * ë¦¬ì‚¬ì´ì¦ˆ ì—†ì´ ì›ë³¸ í¬ê¸°
        * ocr_try_all ì´ langsÃ—psmsÃ—pres ì „ì²´ ì¡°í•©ì„ ëª¨ë‘ ì‹œë„ (ê¸°ì¡´ê³¼ ë™ì¼)
    ë°˜í™˜ê°’ ì˜ˆ:
    {'í•œê¸€','ë“±ë¡ì¦','ë²ˆí˜¸','ë°œê¸‰ì¼','ë§Œê¸°ì¼','ì£¼ì†Œ'}
    """
    out = {}
    if img is None:
        return out

    # ğŸ”¹ FAST ëª¨ë“œì¼ ë•Œë§Œ: ë“±ë¡ì¦ ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì¦ˆ (í•œ ë³€ ìµœëŒ€ 1600px)
    if fast:
        max_side = 1600
        w0, h0 = img.size
        scale = max_side / float(max(w0, h0))
        if scale < 1.0:
            img = img.resize(
                (int(w0 * scale), int(h0 * scale)),
                resample=_PILImage.LANCZOS,
            )

    # ë¦¬ì‚¬ì´ì¦ˆ ë°˜ì˜ëœ í¬ê¸°ë¡œ ìƒÂ·í•˜ë‹¨ ë¶„ë¦¬
    w, h = img.size
    top = img.crop((0, 0, w, int(h*0.5)))
    bot = img.crop((0, int(h*0.5), w, h))

    # ìƒë‹¨: ê¸°ë³¸ OCR
    try:
        # FAST ëª¨ë“œë©´: ì• ì¡°í•© 2ê°œê¹Œì§€ë§Œ ì‹œë„, ì•„ë‹ˆë©´ ì „ì²´ ì¡°í•©
        max_tries = 2 if fast else None
        t_top = ocr_try_all(top, langs=("kor","kor+eng"), max_tries=max_tries)["text"]
    except Exception:
        t_top = ""
    tn_top = t_top

    # ë“±ë¡ì¦ ì•6/ë’¤7
    # ë“±ë¡ì¦ ì•6/ë’¤7
    # ë“±ë¡ì¦ ì•6/ë’¤7
    t_dense = re.sub(r'(?<=\d)\s+(?=\d)', '', tn_top)

    # 1ì°¨: 6ìë¦¬ + (ê¸°í˜¸/ê³µë°±) + 7ìë¦¬ íŒ¨í„´
    pair = re.search(r'(?<!\d)(\d{6})\D{0,20}(\d{7})(?!\d)', t_dense)
    if pair:
        out["ë“±ë¡ì¦"], out["ë²ˆí˜¸"] = pair.group(1), pair.group(2)

    # 2ì°¨: fallback â€“ ì• 6ìë¦¬ë§Œ ì¡í˜”ê±°ë‚˜, ì•„ì§ ë²ˆí˜¸ê°€ ë¹„ì–´ ìˆìœ¼ë©´
    if not out.get("ë“±ë¡ì¦"):
        m6 = re.search(r'(?<!\d)(\d{6})(?!\d)', t_dense)
        if m6:
            out["ë“±ë¡ì¦"] = m6.group(1)

    if out.get("ë“±ë¡ì¦") and not out.get("ë²ˆí˜¸"):
        idx6 = t_dense.find(out["ë“±ë¡ì¦"])
        candidates7 = list(re.finditer(r'(?<!\d)(\d{7})(?!\d)', t_dense))
        if candidates7:
            if idx6 >= 0:
                # ì• 6ìë¦¬ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ 7ìë¦¬ ìˆ«ì ì„ íƒ
                best7 = min(candidates7, key=lambda m: abs(m.start() - idx6))
            else:
                best7 = candidates7[0]
            out["ë²ˆí˜¸"] = best7.group(1)

        # 3ì°¨: ìˆ«ì ë©ì–´ë¦¬ì—ì„œ ê°•ì œ ë¶„í•  (13ìë¦¬ â†’ 6+7)
    if not out.get("ë²ˆí˜¸"):
        for m in re.finditer(r'\d{11,14}', t_dense):
            s = m.group(0)
            if len(s) == 13:
                # 6211146101796 ê°™ì€ ê²½ìš°
                front, back = s[:6], s[6:]
                out.setdefault("ë“±ë¡ì¦", front)
                out["ë²ˆí˜¸"] = back
                break


    # ë°œê¸‰ì¼
    def _find_all_dates(text: str):
        cands = set()
        if not text: return []
        for m in re.finditer(r'(\d{4})[.\-\/](\d{1,2})[.\-\/](\d{1,2})', text):
            y, mo, d = int(m.group(1)), int(m.group(2)), int(m.group(3))
            try: cands.add(_dt(y, mo, d).strftime('%Y-%m-%d'))
            except: pass
        MONTHS = {'JAN':1,'FEB':2,'MAR':3,'APR':4,'MAY':5,'JUN':6,'JUL':7,'AUG':8,'SEP':9,'OCT':10,'NOV':11,'DEC':12}
        for m in re.finditer(r'(\d{1,2})\s*([A-Z]{3})\s*(\d{4})', (text or '').upper()):
            d, mon, y = int(m.group(1)), MONTHS.get(m.group(2),0), int(m.group(3))
            if mon:
                try: cands.add(_dt(y, mon, d).strftime('%Y-%m-%d'))
                except: pass
        return sorted(cands)

    def _pick_labeled_date(text: str, labels_regex: str):
        if not text: return ''
        m1 = re.search(labels_regex + r'[^\d]{0,10}(\d{4}[.\-/]\d{1,2}[.\-/]\d{1,2})', text, re.I)
        if m1:
            return m1.group(1).replace('/', '-').replace('.', '-')
        return ''

    issued = _pick_labeled_date(tn_top, r"(ë°œ\s*ê¸‰|ë°œ\s*í–‰|issue|issued)")
    if not issued:
        ds = _find_all_dates(tn_top)
        if ds:
            issued = ds[0]
    if issued:
        out["ë°œê¸‰ì¼"] = issued

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€ í•œê¸€ ì´ë¦„ ì¶”ì¶œ â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _extract_name_from_text(text: str) -> str:
        ban = {
            "ì™¸êµ­", "êµ­ë‚´", "ê±°ì†Œ", "ì‹ ê³ ", "ì¦", "ì¬ì™¸ë™í¬",
            "ì¬ì™¸", "ë™í¬", "êµ­ì ", "ì£¼ì†Œ", "ë°œê¸‰", "ë°œê¸‰ì¼", "ë°œê¸‰ì¼ì",
            "ë§Œê¸°", "ì²´ë¥˜", "ìê²©", "ì¢…ë¥˜", "ì„±ëª…", "ì´ë¦„"
        }
        m = re.search(r"(ì„±ëª…|ì´ë¦„)\s*[:\-]?\s*([ê°€-í£]{2,4})", text)
        if m and m.group(2) not in ban:
            return m.group(2)
        toks = re.findall(r"[ê°€-í£]{2,4}", text)
        toks = [t for t in toks if t not in ban]
        if not toks:
            return ""
        pos_label = min(
            [p for p in [text.find("ì„±ëª…"), text.find("ì´ë¦„")] if p != -1] + [len(text)//2]
        )
        best, best_d = "", 10**9
        for t in toks:
            p = text.find(t)
            if p != -1:
                d = abs(p - pos_label)
                if d < best_d:
                    best, best_d = t, d
        return best

    def _extract_name_from_roi(img, text_top: str) -> str:
        """
        ë“±ë¡ì¦ ì•ë©´ ê°€ìš´ë° ì´ë¦„ ë°•ìŠ¤ ìª½ì„ í•œ ë²ˆ ë” OCR í•´ì„œ
        ì†ê¸€ì”¨/ìŠ¤í‹°ì»¤ ì´ë¦„(ì˜ˆ: ìœ¤ì›ê¸¸)ì„ ìµœëŒ€í•œ ì¡ì•„ë‚¸ë‹¤.
        """
        try:
            w, h = img.size
            # ì¹´ë“œ ê¸°ì¤€ ëŒ€ëµ ì´ë¦„ ë°•ìŠ¤ ìœ„ì¹˜ (ë¹„ìœ¨ ê¸°ë°˜ì´ì–´ì„œ ìŠ¤ìº” í¬ê¸° ë‹¬ë¼ë„ ìœ ì§€ë¨)
            roi = img.crop((
                int(w * 0.30),  # left
                int(h * 0.30),  # top
                int(w * 0.95),  # right
                int(h * 0.70),  # bottom
            ))
            txt = _fast_ocr(roi, lang="kor", psm=7)
            m = re.search(r"[ê°€-í£]{2,4}", txt)
            if m:
                return m.group(0)
        except Exception:
            pass
        # ROIì—ì„œ ëª» ì°¾ìœ¼ë©´ ê¸°ì¡´ í…ìŠ¤íŠ¸ ê¸°ë°˜ìœ¼ë¡œ
        return _extract_name_from_text(text_top)

    # --- ì´ë¦„ ì¶”ì¶œ ---
    # --- ì´ë¦„ ì¶”ì¶œ (ROI ìš°ì„  + í…ìŠ¤íŠ¸ ë³´ì¡°) ---
    name_ko = _extract_kor_name_strict(t_top)

    if name_ko:
        out["í•œê¸€"] = name_ko

    # í•˜ë‹¨(ë§Œê¸°/ì£¼ì†Œ)
    best_text, best_sc = "", -1
    for deg in (0, 90, 270):
        im = bot.rotate(deg, expand=True)
        t1 = _ocr(ImageOps.grayscale(im), lang="kor", config="--oem 3 --psm 6")
        t2 = _ocr(ImageOps.grayscale(im), lang="kor", config="--oem 3 --psm 4")
        t = (t1 + "\n" + t2)
        sc = _kor_count(t)
        if sc > best_sc:
            best_sc, best_text = sc, t
    tn_bot = best_text

    # ğŸ”š ë§Œê¸°ì¼: í•˜ë‹¨ì—ì„œ ë°œê²¬ëœ "ëª¨ë“  ë‚ ì§œ" ì¤‘ ê°€ì¥ ëŠ¦ì€ ë‚ ì§œë¥¼ ì„ íƒ
    expiry = _pick_labeled_date(
        tn_bot,
        r"(ë§Œê¸°|ìœ íš¨|until|expiry|expiration|valid\s*until|ê¹Œì§€)"
    )
    ds_bot = _find_all_dates(tn_bot)

    # ë°œê¸‰ì¼(issued)ê³¼ ê°™ì€ ë‚ ì§œëŠ” í›„ë³´ì—ì„œ ì œê±°
    if issued and issued in ds_bot:
        try:
            ds_bot.remove(issued)
        except ValueError:
            pass

    # ë¼ë²¨ë¡œ ì¡ì€ ë§Œê¸°ì¼ì´ ìˆìœ¼ë©´ í›„ë³´ì— í¬í•¨
    if expiry:
        ds_bot.append(expiry)

    if ds_bot:
        ds_bot = sorted(set(ds_bot))
        out["ë§Œê¸°ì¼"] = ds_bot[-1]   # ğŸ‘‰ ê°€ì¥ ëŠ¦ì€ ë‚ ì§œ = ìµœì¢… ë§Œê¸°ì¼

    # ì£¼ì†Œ
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì£¼ì†Œ(êµ­ë‚´ê±°ì†Œ) ì¶”ì¶œ â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _clean_addr_line(s: str) -> str:
        s = re.sub(r'^\s*\d{4}[.\-/]\d{1,2}[.\-/]\d{1,2}\s*', '', s or '')
        s = re.sub(r'[^ê°€-í£0-9\s\-\.,#()/~]', ' ', s)
        if ARC_REMOVE_PAREN:
            s = re.sub(r'\([^)]*\)', ' ', s)  # (ì •ì™•ë™) ê°™ì€ ê´„í˜¸ ì œê±°
        s = re.sub(r'\s{2,}', ' ', s).strip(' ,')
        return s

    def _is_junk_addr_line(s: str) -> bool:
        s = (s or '').strip()
        if not s:
            return True
        if _ADDR_BAN_RE.search(s):
            return True
        if _kor_count(s) < 3 and len(re.sub(r'[^\d]', '', s)) >= 6:
            return True
        if re.fullmatch(r'[\(\)\.\-/#\s]+', s):
            return True
        return False

    def _addr_score(s: str) -> float:
        s = _clean_addr_line(s)
        if _is_junk_addr_line(s):
            return -1.0
        has_lvl  = bool(re.search(r'(ë„|ì‹œ|êµ°|êµ¬)', s))
        has_road = bool(re.search(r'(ë¡œ|ê¸¸|ë²ˆê¸¸|ëŒ€ë¡œ)', s))
        has_num  = bool(re.search(r'\d', s))
        has_unit = bool(re.search(r'(ë™|í˜¸|ì¸µ|í˜¸ìˆ˜|#\d+)', s))
        return (
            _kor_count(s)*2 +
            has_lvl*6 + has_road*8 + has_num*4 + has_unit*2 +
            min(len(s), 60)/12.0
        )

    def _best_addr_latest(text: str) -> str:
        """
        êµ­ë‚´ê±°ì†Œ í…Œì´ë¸”ì—ì„œ
        'YYYY.MM.DD + ì£¼ì†Œ' í˜•ì‹ ì¤„ ì¤‘,
        ë‚ ì§œê°€ ê°€ì¥ ìµœê·¼ì¸ ì¤„ì˜ ì£¼ì†Œë¥¼ ìš°ì„  ì‚¬ìš©.
        ì—†ìœ¼ë©´ ê¸°ì¡´ ì ìˆ˜ ê¸°ë°˜ìœ¼ë¡œ fallback.
        """
        lines = [l for l in (text or '').splitlines() if l.strip()]
        best_addr = ""
        best_date = None
        best_sc   = -1.0

        for l in lines:
            if _ADDR_BAN_RE.search(l):
                continue
            m = re.search(r'(\d{4})[.\-/](\d{1,2})[.\-/](\d{1,2})', l)
            if not m:
                continue
            try:
                y, mo, d = int(m.group(1)), int(m.group(2)), int(m.group(3))
                dt = _dt(y, mo, d)
            except ValueError:
                continue

            c  = _clean_addr_line(l)
            sc = _addr_score(c)
            if sc < 0:
                continue

            if (best_date is None) or (dt > best_date) or (dt == best_date and sc > best_sc):
                best_date, best_sc, best_addr = dt, sc, c

        # ë‚ ì§œ ìˆëŠ” ì£¼ì†Œë¥¼ í•˜ë‚˜ë„ ëª» ì°¾ì•˜ìœ¼ë©´,
        # ê¸°ì¡´ ë°©ì‹(ì ìˆ˜ ìµœê³  ì£¼ì†Œ) fallback
        if best_addr:
            return best_addr

        best_i, best_addr2, best_score2 = -1, "", -1
        for i, l in enumerate(lines):
            c = _clean_addr_line(l)
            sc = _addr_score(c)
            if sc > best_score2:
                best_i, best_addr2, best_score2 = i, c, sc
        return best_addr2

    # tn_bot: í•˜ë‹¨ OCR í…ìŠ¤íŠ¸ (ì´ë¯¸ ìœ„ì—ì„œ ê³„ì‚°)
    # tn_bot: í•˜ë‹¨ OCR í…ìŠ¤íŠ¸ (ì´ë¯¸ ìœ„ì—ì„œ ê³„ì‚°)
    addr = _best_addr_latest(tn_bot)
    if addr and _kor_count(addr) >= 3 and len(addr) >= 6:
        out["ì£¼ì†Œ"] = addr
    else:
        # ğŸ‘‰ í•˜ë‹¨ì—ì„œ ëª» ì°¾ì•˜ìœ¼ë©´ ìƒë‹¨+í•˜ë‹¨ ì „ì²´ë¥¼ ëŒ€ìƒìœ¼ë¡œ í•œ ë²ˆ ë” ì‹œë„
        addr2 = _best_addr_latest(t_top + "\n" + tn_bot)
        if addr2 and _kor_count(addr2) >= 3 and len(addr2) >= 6:
            out["ì£¼ì†Œ"] = addr2
                # ê·¸ë˜ë„ ëª» ì°¾ìœ¼ë©´, 'ë„/ì‹œ/ë¡œ/ê¸¸/ë²ˆê¸¸' í¬í•¨ + í•œê¸€ ë§ì€ ì¤„ì„ ê°•ì œë¡œ ì„ íƒ
        if "ì£¼ì†Œ" not in out:
            lines_all = [l.strip() for l in (t_top + "\n" + tn_bot).splitlines() if l.strip()]
            best_line = ""
            best_score = -1
            for l in lines_all:
                if _kor_count(l) < 3:
                    continue
                if not re.search(r'(ë„|ì‹œ|êµ°|êµ¬|ë¡œ|ê¸¸|ë²ˆê¸¸|ëŒ€ë¡œ)', l):
                    continue
                sc = _addr_score(l)
                if sc > best_score:
                    best_score = sc
                    best_line = _clean_addr_line(l)
            if best_line:
                out["ì£¼ì†Œ"] = best_line


    return out


# -----------------------------
# 3) í˜ì´ì§€ ë Œë” í•¨ìˆ˜
# -----------------------------

def render():
    """
    ìŠ¤ìº”ìœ¼ë¡œ ê³ ê° ì¶”ê°€/ìˆ˜ì • í˜ì´ì§€ (ê¸°ì¡´ PAGE_SCAN ì½”ë“œ ëª¨ë“ˆí™” ë²„ì „)
    """

    st.subheader("ğŸ“· ìŠ¤ìº”ìœ¼ë¡œ ê³ ê° ì¶”ê°€/ìˆ˜ì •")
    st.caption("ì—¬ê¶Œ 1ì¥ë§Œ ë˜ëŠ” ì—¬ê¶Œ+ë“±ë¡ì¦ 2ì¥ì„ ì—…ë¡œë“œí•˜ì„¸ìš”.")

    show_debug = st.checkbox(
        "ğŸ§ª ë””ë²„ê·¸ íŒ¨ë„ ë³´ê¸°(ëŠë¦¼)", value=False,
        help="ì²´í¬í•˜ë©´ ì›ë¬¸/ë² ìŠ¤íŠ¸OCR/íŒŒì‹±ê²°ê³¼/í…Œì„œë™íŠ¸ ì§„ë‹¨ì„ í‘œì‹œí•©ë‹ˆë‹¤. (ì†ë„ ì €í•˜)"
    )

    # ë“±ë¡ì¦ FAST ëª¨ë“œ (ê¸°ë³¸ ON)
    fast_arc = st.checkbox(
        "âš¡ ë“±ë¡ì¦ ë¹ ë¥¸ ëª¨ë“œ (ë¦¬ì‚¬ì´ì¦ˆ + OCR ìµœëŒ€ 2íšŒ)",
        value=True,
        help=(
            "ì²´í¬ ì‹œ: ë“±ë¡ì¦ ì´ë¯¸ì§€ë¥¼ ì ë‹¹íˆ ì¤„ì´ê³ , ìƒë‹¨ OCR ì¡°í•©ì„ ì•ì—ì„œë¶€í„° ìµœëŒ€ 2ë²ˆê¹Œì§€ë§Œ ì‹œë„í•©ë‹ˆë‹¤. "
            "í•´ì œ ì‹œ: ì´ë¯¸ì§€ë¥¼ ì›ë³¸ í¬ê¸°ë¡œ ë‘ê³ , langs/psm/ì „ì²˜ë¦¬ ëª¨ë“  ì¡°í•©ì„ ì‹œë„í•´ ì¸ì‹ë¥ ì„ ìµœëŒ€í™”í•©ë‹ˆë‹¤."
        ),
    )

    # Tesseract ì ê²€
    if not _ensure_tesseract():
        st.error("pytesseractê°€ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. `Tesseract-OCR` ì„¤ì¹˜ ë° í™˜ê²½ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.")
        st.stop()

    # ì—…ë¡œë“œ
    cc0, cc1 = st.columns(2)
    with cc0:
        passport_file = st.file_uploader("ì—¬ê¶Œ ì´ë¯¸ì§€/PDF (í•„ìˆ˜)", type=["jpg", "jpeg", "png", "webp", "pdf"])
    with cc1:
        arc_file = st.file_uploader("ë“±ë¡ì¦/ìŠ¤í‹°ì»¤ ì´ë¯¸ì§€ (ì„ íƒ)", type=["jpg", "jpeg", "png", "webp"])

    # ì—…ë¡œë“œëœ íŒŒì¼ì´ ë°”ë€Œë©´ â†’ ìƒˆ ìŠ¤ìº”ìœ¼ë¡œ íŒë‹¨í•˜ê³  prefill í”Œë˜ê·¸ ì´ˆê¸°í™”
    prev_pass = st.session_state.get("_scan_prev_passport_name")
    prev_arc  = st.session_state.get("_scan_prev_arc_name")

    cur_pass = passport_file.name if passport_file is not None else None
    cur_arc  = arc_file.name if arc_file is not None else None

    if (cur_pass, cur_arc) != (prev_pass, prev_arc):
        st.session_state["_scan_prefilled_once"] = False
        st.session_state["_scan_prev_passport_name"] = cur_pass
        st.session_state["_scan_prev_arc_name"] = cur_arc

    # Tesseract ë””ë²„ê·¸
    if show_debug:
        with st.expander("ğŸ”§ Tesseract ì§„ë‹¨ ì •ë³´"):
            try:
                ver = pytesseract.get_tesseract_version()
            except Exception as e:
                ver = f"(ì—ëŸ¬: {e})"
            st.write(f"Tesseract ë²„ì „: {ver}")
            st.write(f"tesseract_cmd: {getattr(pytesseract.pytesseract, 'tesseract_cmd', '')}")
            st.write(f"TESSDATA_PREFIX: {os.environ.get('TESSDATA_PREFIX')}")
            try:
                langs = pytesseract.get_languages()
            except Exception as e:
                langs = f"(ì—ëŸ¬: {e})"
            st.write(f"íƒì§€ëœ ì–¸ì–´ë“¤: {langs}")

    parsed_passport, parsed_arc = {}, {}

    # ì´ë¯¸ì§€/ë¯¸ë¦¬ë³´ê¸° + íŒŒì‹±
    # - PDFëŠ” 1í˜ì´ì§€ê°€ ì•„ë‹Œ ê²½ìš°ê°€ ìˆì–´, ìµœëŒ€ 2í˜ì´ì§€ê¹Œì§€ë§Œ ë¹ ë¥´ê²Œ ìˆœíšŒí•˜ë©° MRZ ì„±ê³µ í˜ì´ì§€ë¥¼ ì„ íƒ
    if passport_file:
        name_lower = (getattr(passport_file, "name", "") or "").lower()
        if name_lower.endswith(".pdf"):
            pdf_bytes = passport_file.getvalue()
            pdf_imgs = _pdf_to_pil_images(pdf_bytes, max_pages=2, zoom=2.5)

            img_p = pdf_imgs[0].convert("RGB") if pdf_imgs else None
            parsed_passport = {}

            # 1~2í˜ì´ì§€ ì¤‘ MRZ íŒŒì‹±ì´ ë˜ëŠ” í˜ì´ì§€ë¥¼ ìš°ì„  ì„ íƒ
            for _im in (pdf_imgs or []):
                _im = _im.convert("RGB")
                _pp = parse_passport(_im)
                if _pp and any(v for v in _pp.values()):
                    img_p = _im
                    parsed_passport = _pp
                    break
        else:
            img_p = open_image_safe(passport_file)
            parsed_passport = parse_passport(img_p)
    else:
        img_p = None

    if arc_file:
        img_a = open_image_safe(arc_file)
        # ğŸ”¹ FAST ëª¨ë“œ on/off ì— ë”°ë¼ ë“±ë¡ì¦ íŒŒì‹± ì „ëµ ë³€ê²½
        parsed_arc = parse_arc(img_a, fast=fast_arc)
    else:
        img_a = None



    # ë² ìŠ¤íŠ¸ OCR ì›ë¬¸ ë””ë²„ê·¸
    if show_debug:
        with st.expander("ğŸ§ª OCR ì›ë¬¸(ë² ìŠ¤íŠ¸ ì„¤ì •)", expanded=False):
            if img_p is not None:
                bp = ocr_try_all(img_p, langs=('eng',), psms=(6,7), pres=('raw','binarize'))
                st.write({"lang": bp["lang"], "config": bp["config"], "pre": bp["pre"], "score": bp["score"]})
                st.code(bp["text"][:2000])
            if img_a is not None:
                ba = ocr_try_all(img_a)
                st.write({"lang": ba["lang"], "config": ba["config"], "pre": ba["pre"], "score": ba["score"]})
                st.code(ba["text"][:2000])

    # MRZ/ARC ì›ë¬¸ + íŒŒì‹± ê²°ê³¼ ë””ë²„ê·¸
    if show_debug:
        if img_p is not None:
            with st.expander("ğŸ” ì—¬ê¶Œ MRZ ì›ë¬¸ ìƒ˜í”Œ"):
                w, h = img_p.size
                mrz_crop = img_p.crop((0, int(h*0.6), w, h))
                mrz_bin = _binarize(mrz_crop)
                st.image(mrz_bin, caption="MRZ(í•˜ë‹¨ë¶€) ìƒ˜í”Œ", use_container_width=True)
                st.code(_ocr(
                    mrz_bin,
                    "eng",
                    "--oem 3 --psm 7 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ<0123456789"
                ))

        if img_a is not None:
            with st.expander("ğŸ” ë“±ë¡ì¦ ì „ì²´ OCR(ë¹ ë¥¸ ì´ì§„í™” 1íšŒ)"):
                st.code(_ocr(_binarize(img_a), "kor", "--oem 3 --psm 6")[:2000])

        with st.expander("ğŸ§ª OCR íŒŒì‹± ê²°ê³¼(ë””ë²„ê·¸)"):
            st.json({"passport": parsed_passport, "arc": parsed_arc})

    # OCR ê²°ê³¼ â†’ ì„¸ì…˜ ì±„ìš°ê¸°
    def _prefill_from_ocr(p, a):
        changed = False

        def setk(field, val):
            nonlocal changed
            k = f"scan_{field}"
            v = (val or "").strip()
            if not v:
                return

            # ê°’ì´ ë‹¬ë¼ì§€ë©´ ë¬´ì¡°ê±´ ìƒˆ OCR ê°’ìœ¼ë¡œ ë®ì–´ì“´ë‹¤
            # ğŸ‘‡ ì´ê±¸ë¡œ êµì²´
            cur = str(st.session_state.get(k, "")).strip()
            if cur != v:
                st.session_state[k] = v
                changed = True

        setk("í•œê¸€",     a.get("í•œê¸€"))
        setk("ì„±",       p.get("ì„±"))
        setk("ëª…",       p.get("ëª…"))
        setk("ì—¬ê¶Œ",     p.get("ì—¬ê¶Œ"))
        setk("ì—¬ê¶Œë°œê¸‰", p.get("ë°œê¸‰"))
        setk("ì—¬ê¶Œë§Œê¸°", p.get("ë§Œê¸°"))
        setk("êµ­ê°€",     p.get("êµ­ê°€"))
        setk("ì„±ë³„",     p.get("ì„±ë³„"))
        setk("ìƒë…„ì›”ì¼", p.get("ìƒë…„ì›”ì¼"))
        setk("ë“±ë¡ì¦",   a.get("ë“±ë¡ì¦"))
        setk("ë²ˆí˜¸",     a.get("ë²ˆí˜¸"))
        setk("ë°œê¸‰ì¼",   a.get("ë°œê¸‰ì¼"))
        setk("ë§Œê¸°ì¼",   a.get("ë§Œê¸°ì¼"))
        setk("ì£¼ì†Œ",     a.get("ì£¼ì†Œ"))

        # ì—¬ê¶Œ ìƒë…„ì›”ì¼ë¡œ ë“±ë¡ì¦ ì•ìë¦¬ ì±„ìš°ê¸°
        birth = (p.get("ìƒë…„ì›”ì¼") or "").strip()
        if birth:
            try:
                yymmdd = _dt.strptime(birth, "%Y-%m-%d").strftime("%y%m%d")
                if not str(st.session_state.get("scan_ë“±ë¡ì¦", "")).strip():
                    st.session_state["scan_ë“±ë¡ì¦"] = yymmdd
                    changed = True
            except Exception:
                pass

        return changed

    # ğŸ‘‡ ì´ê±¸ë¡œ êµì²´
    if not st.session_state.get("_scan_prefilled_once"):
        if _prefill_from_ocr(parsed_passport, parsed_arc):
            st.session_state["_scan_prefilled_once"] = True
            st.rerun()

    # -----------------------------
    # í™•ì¸/ìˆ˜ì • í¼ (2 x 2 ë ˆì´ì•„ì›ƒ)
    # -----------------------------
    if "scan_ì—°" not in st.session_state or not str(st.session_state["scan_ì—°"]).strip():
        st.session_state["scan_ì—°"] = "010"

    st.markdown("### ğŸ” ìŠ¤ìº” ê²°ê³¼ í™•ì¸ ë° ìˆ˜ì •")

    with st.form("scan_confirm_form"):
        # 1) ì²«ë²ˆì§¸ ê°€ë¡œ ì¤„: ì—¬ê¶Œ (ì´ë¯¸ì§€ 70% + ì •ë³´ 30%)
        row1_img_col, row1_info_col = st.columns([7, 3])

        with row1_img_col:
            st.markdown("#### ì—¬ê¶Œ ì´ë¯¸ì§€")
            if img_p is not None:
                st.image(img_p, caption="ì—¬ê¶Œ", use_container_width=True)
            else:
                st.info("ì—¬ê¶Œ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”.")

        with row1_info_col:
            # ğŸ”¹ ì—¬ê¶Œ ì´ë¯¸ì§€ ë†’ì´ì— ë§ì¶° ëŒ€ëµ ì¤‘ì•™ì¯¤ì—ì„œ ì‹œì‘í•˜ë„ë¡ ìœ„ìª½ ì—¬ë°± ì¶”ê°€
            st.markdown("#### ì—¬ê¶Œ ì •ë³´")
            st.write("")
            st.write("")
            ì„±   = st.text_input("ì„±(ì˜ë¬¸)", key="scan_ì„±")
            ëª…   = st.text_input("ëª…(ì˜ë¬¸)", key="scan_ëª…")
            ì—¬ê¶Œ     = st.text_input("ì—¬ê¶Œë²ˆí˜¸", key="scan_ì—¬ê¶Œ")
            ì—¬ê¶Œë°œê¸‰ = st.text_input("ì—¬ê¶Œ ë°œê¸‰ì¼(YYYY-MM-DD)", key="scan_ì—¬ê¶Œë°œê¸‰")
            ì—¬ê¶Œë§Œê¸° = st.text_input("ì—¬ê¶Œ ë§Œê¸°ì¼(YYYY-MM-DD)", key="scan_ì—¬ê¶Œë§Œê¸°")

            êµ­ê°€ì½”ë“œ = st.text_input("êµ­ì (3ìë¦¬ ì½”ë“œ)", key="scan_êµ­ê°€")
            ì„±ë³„ = st.text_input("ì„±ë³„(M/F/ë‚¨/ì—¬)", key="scan_ì„±ë³„")
            ìƒë…„ì›”ì¼ = st.text_input("ìƒë…„ì›”ì¼(YYYY-MM-DD)", key="scan_ìƒë…„ì›”ì¼")

            # ë³´ê¸°ìš© êµ­ê°€ëª…
            cn = _country_name((êµ­ê°€ì½”ë“œ or "").strip())
            if cn and cn != (êµ­ê°€ì½”ë“œ or "").strip().upper():
                st.caption(f"êµ­ê°€ëª…: {cn}")


        # 2) ë‘ë²ˆì§¸ ê°€ë¡œ ì¤„: ë“±ë¡ì¦ (ì´ë¯¸ì§€ 70% + ì •ë³´ 30%)
        row2_img_col, row2_info_col = st.columns([7, 3])

        with row2_img_col:
            st.markdown("#### ë“±ë¡ì¦ / ìŠ¤í‹°ì»¤ ì´ë¯¸ì§€")
            if img_a is not None:
                st.image(img_a, caption="ë“±ë¡ì¦/ìŠ¤í‹°ì»¤", use_container_width=True)
            else:
                st.info("ë“±ë¡ì¦/ìŠ¤í‹°ì»¤ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤.")

        with row2_info_col:
            # ğŸ”¹ ë“±ë¡ì¦ ì´ë¯¸ì§€ ì¤‘ì•™ì¯¤ì—ì„œ ì…ë ¥ì´ ì‹œì‘ë˜ë„ë¡ ìœ„ìª½ ì—¬ë°± ì¶”ê°€
            st.markdown("#### ë“±ë¡ì¦ / ì—°ë½ì²˜ ì •ë³´")
            st.write("")
            st.write("")
            í•œê¸€   = st.text_input("í•œê¸€ ì´ë¦„", key="scan_í•œê¸€")
            ë“±ë¡ì¦ = st.text_input("ë“±ë¡ì¦ ì•(YYMMDD)", key="scan_ë“±ë¡ì¦")
            ë²ˆí˜¸   = st.text_input("ë“±ë¡ì¦ ë’¤ 7ìë¦¬",   key="scan_ë²ˆí˜¸")
            ë°œê¸‰ì¼ = st.text_input("ë“±ë¡ì¦ ë°œê¸‰ì¼(YYYY-MM-DD)", key="scan_ë°œê¸‰ì¼")
            ë§Œê¸°ì¼ = st.text_input("ë“±ë¡ì¦ ë§Œê¸°ì¼(YYYY-MM-DD)", key="scan_ë§Œê¸°ì¼")
            ì£¼ì†Œ   = st.text_input("ì£¼ì†Œ", key="scan_ì£¼ì†Œ")

            p1, p2, p3, p4 = st.columns([1, 1, 1, 0.7])
            ì—°   = p1.text_input("ì—°(ì• 3ìë¦¬)", key="scan_ì—°")
            ë½   = p2.text_input("ë½(ì¤‘ê°„ 4ìë¦¬)", key="scan_ë½")
            ì²˜   = p3.text_input("ì²˜(ë 4ìë¦¬)", key="scan_ì²˜")
            V    = p4.text_input("V", key="scan_V")


        submitted = st.form_submit_button("ğŸ’¾ ê³ ê°ê´€ë¦¬ ë°˜ì˜", use_container_width=True)
        if submitted:
            passport_data = {
                "ì„±":   ì„±.strip(),
                "ëª…":   ëª….strip(),
                "ì—¬ê¶Œ": ì—¬ê¶Œ.strip(),
                "ë°œê¸‰": ì—¬ê¶Œë°œê¸‰.strip(),
                "ë§Œê¸°": ì—¬ê¶Œë§Œê¸°.strip(),
                "êµ­ê°€": (êµ­ê°€ì½”ë“œ or "").strip(),
                "ì„±ë³„": (ì„±ë³„ or "").strip(),
                "ìƒë…„ì›”ì¼": (ìƒë…„ì›”ì¼ or "").strip(),
            }
            arc_data = {
                "í•œê¸€":   í•œê¸€.strip(),
                "ë“±ë¡ì¦": ë“±ë¡ì¦.strip(),
                "ë²ˆí˜¸":   ë²ˆí˜¸.strip(),
                "ë°œê¸‰ì¼": ë°œê¸‰ì¼.strip(),
                "ë§Œê¸°ì¼": ë§Œê¸°ì¼.strip(),
                "ì£¼ì†Œ":   ì£¼ì†Œ.strip(),
            }
            extra_data = {
                "ì—°": ì—°.strip(),
                "ë½": ë½.strip(),
                "ì²˜": ì²˜.strip(),
                "V":  V.strip(),
            }

            ok, msg = upsert_customer_from_scan(passport_data, arc_data, extra_data)

            if ok:
                st.session_state["scan_saved_ok"] = True
                st.success(f"âœ… {msg}")
            else:
                st.error(f"âŒ {msg}")

            if st.session_state.get("scan_saved_ok"):
                st.success("âœ… ê³ ê°ê´€ë¦¬ ë°ì´í„°ì— ë°˜ì˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")


    if st.button("â† ê³ ê°ê´€ë¦¬ë¡œ ëŒì•„ê°€ê¸°", use_container_width=True):
        st.session_state[SESS_CURRENT_PAGE] = PAGE_CUSTOMER
        st.rerun()
